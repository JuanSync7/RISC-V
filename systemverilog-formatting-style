################################################################################
# ProjectName/TeamName SystemVerilog RTL Coding and Formatting Style Guide
# Version: 2.1
# Last Updated: 2025-01-17
################################################################################

#----
# Introduction
#----
# This document defines the SystemVerilog coding and formatting style for RTL
# design. Adherence to these guidelines is mandatory to ensure code
# consistency, readability, maintainability, and to facilitate collaboration,
# synthesis, and verification.
#
# This guide complements the IEEE 1800-2017 SystemVerilog standard.
# For language semantics and syntax, refer to IEEE 1800-2017.
#

#----
# 1. General Formatting
#----
# 1.1. Character Encoding:
#      - UTF-8
#
# 1.2. Line Length:
#      - Maximum 120 characters. Break longer lines for readability.
#
# 1.3. Indentation:
#      - 4 spaces per indentation level. Do NOT use tabs.
#
# 1.4. `timescale:
#      - `timescale 1ns/1ps must be declared at the top of every SystemVerilog
#        file (`.sv`, `.svh`).
#
# 1.5. `default_nettype:
#      - `default_nettype none must be used at the top of each RTL file
#        after `timescale to prevent implicit wire declarations.
#
# 1.6. Comments:
#      - // for single-line comments.
#      - /* ... */ for multi-line block comments (use sparingly in RTL, prefer //).
#      - Use meaningful comments to explain complex logic, design trade-offs,
#        or non-obvious code sections.
#      - Standard Tags:
#        // TODO: Item needing completion.
#        // FIXME: Item that is broken and needs fixing.
#        // NOTE: Important information or clarification.
#        // INFO: General information.
#        // WARNING: Potential issue or caution.
#        // REVIEW: Code section that needs review.
#
# 1.7. Preprocessor Directives for Simulation/Synthesis:
#      - Clearly delineate code sections for simulation-only or synthesis-only
#        using standard preprocessor directives:
#        `ifdef SIMULATION
#          // Simulation-only code (e.g., display statements, specific checks)
#        `endif
#
#        `ifdef SYNTHESIS
#          // Synthesis-only code (rare, usually for tool-specific attributes)
#        `else
#          // Code for non-synthesis tools or alternative implementation if SYNTHESIS is not defined
#        `endif
#
#        // Alternatively, for code to be excluded from synthesis (prefer the `ifdef method):
#        // synthesis translate_off
#        ...
#        // synthesis translate_on

#----
# 2. Naming Conventions
#----
# 2.1. General:
#      - Use descriptive names. Avoid single-letter names except for loop variables (i, j, k).
#      - Use snake_case for signals, variables, and most identifiers unless specified.
#      - Use snake_case for module names, interface names, package names, class names, and typedefs.
#      - Use UPPER_CASE for parameters, localparams, and macros.
#
# 2.2. File Naming:
#      - RTL Modules:       module_name.sv          (e.g., data_processor.sv)
#      - Testbenches:       ModuleName_tb.sv       (e.g., data_processor_tb.sv)
#      - Packages:          feature_name_pkg.sv     (e.g., axi_utils_pkg.sv)
#      - Interfaces:        purpose_name_if.sv      (e.g., axi_stream_if.sv)
#      - Include Files:     header_name_hdr.svh     (e.g., defines_hdr.svh)
#      - Constraints:       module_name.sdc         (e.g., data_processor.sdc)
#
# 2.3. Module and Interface Names:
#      - snake_case (e.g., `my_module`, `standard_bus_if`).
#
# 2.4. Signal Naming:
#      - Suffixes:
#        - `_i`: input port
#        - `_o`: output port
#        - `_io`: inout port
#        - `_r`: registered signal (output of a flip-flop)
#        - `_ns`: next-state signal for a registered signal (combinational)
#        - `_c` or `_comb`: combinational logic signal (if clarity needed beyond _ns)
#        - `_w`: wire (explicitly, if needed for clarity, often implicit)
#        - `_en`: enable signal
#        - `_busy`: busy status signal
#        - `_valid`: valid signal
#        - `_ready`: ready signal
#        - `_ack`: acknowledge signal
#        - `_req`: request signal
#        - `_done`: done signal
#        - `_data`: data bus (e.g., `tx_data_i`, `mem_addr_o`)
#        - `_addr`: address bus
#        - `_wr`: write signal (e.g., `axi_awvalid_i`)
#        - `_rd`: read signal (e.g., `axi_arvalid_i`)
#        - `_sync`: signal synchronized across clock domains
#      - Prefixes:
#        - `clk_`: clock signals (e.g., `clk_core`, `clk_mem`)
#        - `rst_n_` or `arst_n_`: active-low asynchronous reset (project-specific choice, be consistent)
#        - `srst_n_` or `rst_n_`: active-low synchronous reset (project-specific choice, be consistent)
#        - `rst_p_`: active-high reset (less common for top-level resets)
#      - State Machine Signals:
#        - State register: `state_r`
#        - Next state logic: `state_ns`
#        - State encoding: `S_IDLE`, `S_FETCH`, `S_DECODE` (use enums for states)
#      - Bus Connections: Always `[MSB:LSB]` (e.g., `logic [31:0] data_bus;`)
#
# 2.5. Parameters and Localparams:
#      - UPPER_CASE_SNAKE_CASE (e.g., `DATA_WIDTH`, `FIFO_DEPTH`).
#      - Parameter Classification and Naming:
#        a) Configurable Parameters (can be overridden during instantiation):
#           - Prefix: `CONFIG_` for module parameters (e.g., `CONFIG_DATA_WIDTH`, `CONFIG_FIFO_DEPTH`)
#           - These represent design-time configurable values that affect module behavior
#           - Examples: `CONFIG_DATA_WIDTH`, `CONFIG_CACHE_SIZE`, `CONFIG_NUM_PORTS`
#        
#        b) Design Constants (fixed values, not meant to be overridden):
#           - Prefix: `CONST_` for constants (e.g., `CONST_AXI_BURST_INCR`, `CONST_RESET_CYCLES`)
#           - These represent architectural constants or protocol-defined values
#           - Examples: `CONST_AXI_RESP_OKAY`, `CONST_PIPELINE_STAGES`, `CONST_DEFAULT_TIMEOUT`
#           - NOTE: Do NOT use `CONST_` for FSM states (use simple `S_IDLE`, `S_ACTIVE`, etc.)
#        
#        c) Local Parameters (derived or internal constants):
#           - Prefix: `LP_` for localparams (e.g., `LP_ADDR_BITS`, `LP_COUNT_WIDTH`)
#           - These are calculated from other parameters or internal design constants
#           - Examples: `LP_ADDR_BITS = $clog2(CONFIG_FIFO_DEPTH)`, `LP_TOTAL_WIDTH = CONFIG_DATA_WIDTH + CONFIG_TAG_WIDTH`
#        
#        d) Type Parameters:
#           - Prefix: `TYPE_` for type parameters (e.g., `TYPE_ADDR`, `TYPE_DATA`)
#           - Examples: `TYPE_ADDR = logic [31:0]`, `TYPE_REQ = cpu_req_s`
#
# 2.6. Type Definitions (typedefs, enums, structs):
#      - typedefs uses snake_case with `_t` suffix (e.g., `address_t`, `state_type_t`, `config_bus_t`).
#      - enums uses snake_case with `_e` suffix (e.g., `color_e`, `machine_fsm_e`).
#      - structs uses snake_case with `_s` suffix (e.g., `write_addr_s`, `read_resp_s`)
#
# 2.7. FSM State Naming (Special Case):
#      - FSM states should use simple descriptive names with `S_` prefix
#      - Examples: `S_IDLE`, `S_ACTIVE`, `S_FETCH`, `S_DECODE`, `S_EXECUTE`, `S_DONE`
#      - Do NOT use `CONST_` prefix for FSM states (they are internal state encodings, not design constants)
#      - Prefer using enums for state definitions when possible:
#        `typedef enum logic [1:0] { S_IDLE, S_ACTIVE, S_DONE } state_e;`
#
# 2.8. Instances:
#      - `u_<ModuleName>` or `<module_name_instance_purpose>` (e.g., `u_data_fifo`, `data_path_fifo`). Be consistent.
#
# 2.9. Generate Blocks:
#      - `gen_<purpose>` (e.g., `gen_lanes[i].u_LaneLogic`).
#      - Ensure that there is no generate block labels that are identical.
#
# 2.10. Assertions and Sequences:
#      - `assert_<property_name>` for assertions.
#      - `seq_<sequence_name>` for sequences.
#      - `prop_<property_name>` for properties.
#      - `cg_<group_name>` for covergroups.
#      - `cp_<point_name>` for coverpoints.
#
#----
# 3. Directory Structure
#----
# project_root/
# ├── doc/                  // Design documents, specifications
# ├── rtl/                  // All synthesizable RTL SystemVerilog code (.sv)
# │   ├── config/           // Configuration packages and parameter definitions
# │   │   ├── global/       // Global system configuration
# │   │   ├── core/         // Core-specific configuration
# │   │   ├── memory/       // Memory subsystem configuration
# │   │   └── protocol/     // Protocol-specific configuration
# │   ├── protocol/         // Protocol implementations and adapters
# │   │   ├── axi/          // AXI protocol implementations
# │   │   ├── chi/          // CHI protocol implementations
# │   │   ├── tilelink/     // TileLink protocol implementations
# │   │   └── custom/       // Custom protocol implementations
# │   ├── shared/           // Shared/common modules and utilities
# │   │   ├── interfaces/   // Common interface definitions
# │   │   ├── primitives/   // Basic building blocks (FIFOs, arbiters, etc.)
# │   │   ├── utils/        // Utility modules and functions
# │   │   └── packages/     // Shared packages and type definitions
# │   ├── core/             // Core logic modules
# │   │   ├── pipeline/     // Pipeline stages
# │   │   ├── execution/    // Execution units
# │   │   ├── control/      // Control logic
# │   │   └── integration/  // Core integration modules
# │   ├── memory/           // Memory subsystem
# │   │   ├── cache/        // Cache implementations
# │   │   ├── coherency/    // Cache coherency logic
# │   │   ├── controllers/  // Memory controllers
# │   │   └── wrappers/     // Memory interface wrappers
# │   ├── units/            // Functional units (ALU, FPU, etc.)
# │   ├── power/            // Power management modules
# │   ├── peripherals/      // Peripheral modules
# │   └── verification/     // RTL verification helpers and checkers
# ├── tb/                   // Testbench code
# │   ├── top/              // Top-level testbench files (_tb.sv)
# │   ├── uvm/              // UVM components (agents, envs, sequences, tests)
# │   │   ├── agents/
# │   │   ├── envs/
# │   │   ├── sequences/
# │   │   └── tests/
# │   ├── common/           // Common testbench utilities, tasks, checkers
# │   └── vip/              // Verification IP
# ├── pkg/                  // SystemVerilog packages (.sv) (parameters, typedefs, utility functions)
# ├── syn/                  // Synthesis scripts, SDC constraints, reports
# │   ├── scripts/
# │   ├── constraints/      // Timing constraints (.sdc)
# │   └── reports/
# ├── formal/               // Formal verification scripts and properties
# ├── scripts/              // General utility scripts (lint, build, etc.)
# └── sim/                  // Simulation scripts, build directories (tool specific)
#
#----
# 4. Module and Interface Declarations
#----
# 4.1. File Header:
#      - Every `.sv` and `.svh` file must start with a standard header.
#
#        ```systemverilog
#        //=============================================================================
#        // Company: <Company Name>
#        // Project Name: <ProjectName>
#        //
#        // File: <FileName.sv> // The name of the current file.
#        //
#        // ----- Fields for Automated Documentation -----
#        // MODULE_NAME: <ModuleName> // Name of the module defined in this file.
#        // AUTHOR: <Author Name> (<author_email@company.com>) // Author of the module.
#        // VERSION: <X.Y.Z> // Version of the module.
#        // DATE: <YYYY-MM-DD> // Date of creation or last significant update.
#        // DESCRIPTION: <Brief, single-line description of the module's purpose.>
#        // PRIMARY_PURPOSE: <Detailed purpose of the module.>
#        // ROLE_IN_SYSTEM: <How this module fits into a larger system.>
#        // PROBLEM_SOLVED: <What specific problem this module addresses.>
#        // MODULE_TYPE: <e.g., RTL, Behavioral, Testbench_Component>
#        // TARGET_TECHNOLOGY_PREF: <ASIC/FPGA> // Preferred target technology.
#        // RELATED_SPECIFICATION: <Document_Name_Or_Link_to_Spec> // Link to relevant specs.
#        //
#        // ----- Status and Tracking -----
#        // VERIFICATION_STATUS: <Not Verified | In Progress | Verified | Formally Verified>
#        // QUALITY_STATUS: <Draft | Reviewed | Approved | Released>
#        //
#        //=============================================================================
#        //
#        `timescale 1ns/1ps
#        `default_nettype none // IMPORTANT: All signals must be explicitly typed
#        //
#        ```
#
# 4.1.1 File Footer:
#      - Every `.sv` and `.svh` file must end with a standard footer.
#      - The footer must include instantiation tracking to support dependency management
#        and enable intelligent tool-assisted edits, especially for port changes.
#        ```systemverilog
#        //=============================================================================
#        // Dependencies: <list of files/modules this module depends on>
#        //   - dependency1.sv (package or module used)
#        //   - dependency2_pkg.sv (imported package)
#        //
#        // Instantiated In: <files where this module is instantiated>
#        //   - <parent_module_name> in <file_name.sv> (instance: <instance_name>)
#        //   - <parent_module_name> in <file_name.sv> (instance: <instance_name>)
#        //   - <testbench_name> in <tb_file_name.sv> (instance: <instance_name>)
#        //
#        // Performance:
#        //   - Critical Path: <expected critical path>
#        //   - Max Frequency: <range of frequency>
#        //   - Area: <rough estimate>
#        //
#        // Verification Coverage:
#        //   - Code Coverage: <Coverage from tool>
#        //   - Functional Coverage: <Coverage from tool>
#        //   - Branch Coverage: <Coverage from tool>
#        //
#        // Synthesis:
#        //   - Target Technology: ASIC/FPGA
#        //   - Synthesis Tool: Design Compiler/Quartus
#        //   - Clock Domains: <number of clk domain>
#        //   - Constraints File: <SDC file name>
#        //
#        // Testing:
#        //   - Testbench: <testbench name>
#        //   - Test Vectors: <number of test vectors in testbench mentioned above>
#        //
#        //----
#        // Revision History:
#        // Version | Date       | Author             | Description
#        //=============================================================================
#        // 1.1.0   | YYYY-MM-DD | <Author Name>      | Added X / Implemented Y (Summary of changes)
#        // 1.0.0   | YYYY-MM-DD | <Author Name>      | Initial release
#        //=============================================================================
#        ```