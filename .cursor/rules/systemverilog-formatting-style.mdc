---
description: Systemverilog Style Formatting. Must when generating Systemverilog code for consistency.
globs: 
alwaysApply: false
---
################################################################################
# ProjectName/TeamName SystemVerilog RTL Coding and Formatting Style Guide
# Version: 2.0
# Last Updated: 2025-05-25
################################################################################

#-------------------------------------------------------------------------------
# Introduction
#-------------------------------------------------------------------------------
# This document defines the SystemVerilog coding and formatting style for RTL
# design. Adherence to these guidelines is mandatory to ensure code
# consistency, readability, maintainability, and to facilitate collaboration,
# synthesis, and verification.
#
# This guide complements the IEEE 1800-2017 SystemVerilog standard.
# For language semantics and syntax, refer to IEEE 1800-2017.
#

#-------------------------------------------------------------------------------
# 1. General Formatting
#-------------------------------------------------------------------------------
# 1.1. Character Encoding:
#      - UTF-8
#
# 1.2. Line Length:
#      - Maximum 120 characters. Break longer lines for readability.
#
# 1.3. Indentation:
#      - 4 spaces per indentation level. Do NOT use tabs.
#
# 1.4. `timescale:
#      - `timescale 1ns/1ps must be declared at the top of every SystemVerilog
#        file (`.sv`, `.svh`).
#
# 1.5. `default_nettype:
#      - `default_nettype none must be used at the top of each RTL file
#        after `timescale to prevent implicit wire declarations.
#
# 1.6. Comments:
#      - // for single-line comments.
#      - /* ... */ for multi-line block comments (use sparingly in RTL, prefer //).
#      - Use meaningful comments to explain complex logic, design trade-offs,
#        or non-obvious code sections.
#      - Standard Tags:
#        // TODO: Item needing completion.
#        // FIXME: Item that is broken and needs fixing.
#        // NOTE: Important information or clarification.
#        // INFO: General information.
#        // WARNING: Potential issue or caution.
#        // REVIEW: Code section that needs review.
#
# 1.7. Preprocessor Directives for Simulation/Synthesis:
#      - Clearly delineate code sections for simulation-only or synthesis-only
#        using standard preprocessor directives:
#        `ifdef SIMULATION
#          // Simulation-only code (e.g., display statements, specific checks)
#        `endif
#
#        `ifdef SYNTHESIS
#          // Synthesis-only code (rare, usually for tool-specific attributes)
#        `else
#          // Code for non-synthesis tools or alternative implementation if SYNTHESIS is not defined
#        `endif
#
#        // Alternatively, for code to be excluded from synthesis (prefer the `ifdef method):
#        // synthesis translate_off
#        ...
#        // synthesis translate_on

#-------------------------------------------------------------------------------
# 2. Naming Conventions
#-------------------------------------------------------------------------------
# 2.1. General:
#      - Use descriptive names. Avoid single-letter names except for loop variables (i, j, k).
#      - Use snake_case for signals, variables, and most identifiers unless specified.
#      - Use snake_case for module names, interface names, package names, class names, and typedefs.
#      - Use UPPER_CASE for parameters, localparams, and macros.
#
# 2.2. File Naming:
#      - RTL Modules:       module_name.sv          (e.g., data_processor.sv)
#      - Testbenches:       ModuleName_tb.sv       (e.g., data_processor_tb.sv)
#      - Packages:          feature_name_pkg.sv     (e.g., axi_utils_pkg.sv)
#      - Interfaces:        purpose_name_if.sv      (e.g., axi_stream_if.sv)
#      - Include Files:     header_name_hdr.svh     (e.g., defines_hdr.svh)
#      - Constraints:       module_name.sdc         (e.g., data_processor.sdc)
#
# 2.3. Module and Interface Names:
#      - snake_case (e.g., `my_module`, `standard_bus_if`).
#
# 2.4. Signal Naming:
#      - Suffixes:
#        - `_i`: input port
#        - `_o`: output port
#        - `_io`: inout port
#        - `_r`: registered signal (output of a flip-flop)
#        - `_ns`: next-state signal for a registered signal (combinational)
#        - `_c` or `_comb`: combinational logic signal (if clarity needed beyond _ns)
#        - `_w`: wire (explicitly, if needed for clarity, often implicit)
#        - `_en`: enable signal
#        - `_busy`: busy status signal
#        - `_valid`: valid signal
#        - `_ready`: ready signal
#        - `_ack`: acknowledge signal
#        - `_req`: request signal
#        - `_done`: done signal
#        - `_data`: data bus (e.g., `tx_data_i`, `mem_addr_o`)
#        - `_addr`: address bus
#        - `_wr`: write signal (e.g., `axi_awvalid_i`)
#        - `_rd`: read signal (e.g., `axi_arvalid_i`)
#        - `_sync`: signal synchronized across clock domains
#      - Prefixes:
#        - `clk_`: clock signals (e.g., `clk_core`, `clk_mem`)
#        - `rst_n_` or `arst_n_`: active-low asynchronous reset (project-specific choice, be consistent)
#        - `srst_n_` or `rst_n_`: active-low synchronous reset (project-specific choice, be consistent)
#        - `rst_p_`: active-high reset (less common for top-level resets)
#      - State Machine Signals:
#        - State register: `state_r`
#        - Next state logic: `state_ns`
#        - State encoding: `S_IDLE`, `S_FETCH`, `S_DECODE` (use enums for states)
#      - Bus Connections: Always `[MSB:LSB]` (e.g., `logic [31:0] data_bus;`)
#
# 2.5. Parameters and Localparams:
#      - UPPER_CASE_SNAKE_CASE (e.g., `DATA_WIDTH`, `FIFO_DEPTH`).
#      - Parameter Classification and Naming:
#        a) Configurable Parameters (can be overridden during instantiation):
#           - Prefix: `CONFIG_` for module parameters (e.g., `CONFIG_DATA_WIDTH`, `CONFIG_FIFO_DEPTH`)
#           - These represent design-time configurable values that affect module behavior
#           - Examples: `CONFIG_DATA_WIDTH`, `CONFIG_CACHE_SIZE`, `CONFIG_NUM_PORTS`
#        
#        b) Design Constants (fixed values, not meant to be overridden):
#           - Prefix: `CONST_` for constants (e.g., `CONST_AXI_BURST_INCR`, `CONST_RESET_CYCLES`)
#           - These represent architectural constants or protocol-defined values
#           - Examples: `CONST_AXI_RESP_OKAY`, `CONST_PIPELINE_STAGES`, `CONST_DEFAULT_TIMEOUT`
#           - NOTE: Do NOT use `CONST_` for FSM states (use simple `S_IDLE`, `S_ACTIVE`, etc.)
#        
#        c) Local Parameters (derived or internal constants):
#           - Prefix: `LP_` for localparams (e.g., `LP_ADDR_BITS`, `LP_COUNT_WIDTH`)
#           - These are calculated from other parameters or internal design constants
#           - Examples: `LP_ADDR_BITS = $clog2(CONFIG_FIFO_DEPTH)`, `LP_TOTAL_WIDTH = CONFIG_DATA_WIDTH + CONFIG_TAG_WIDTH`
#        
#        d) Type Parameters:
#           - Prefix: `TYPE_` for type parameters (e.g., `TYPE_ADDR`, `TYPE_DATA`)
#           - Examples: `TYPE_ADDR = logic [31:0]`, `TYPE_REQ = cpu_req_s`
#
# 2.6. Type Definitions (typedefs, enums, structs):
#      - typedefs uses snake_case with `_t` suffix (e.g., `address_t`, `state_type_t`, `config_bus_t`).
#      - enums uses snake_case with `_e` suffix (e.g., `color_e`, `machine_fsm_e`).
#      - structs uses snake_case with `_s` suffix (e.g., `write_addr_s`, `read_resp_s`)
#
# 2.7. FSM State Naming (Special Case):
#      - FSM states should use simple descriptive names with `S_` prefix
#      - Examples: `S_IDLE`, `S_ACTIVE`, `S_FETCH`, `S_DECODE`, `S_EXECUTE`, `S_DONE`
#      - Do NOT use `CONST_` prefix for FSM states (they are internal state encodings, not design constants)
#      - Prefer using enums for state definitions when possible:
#        `typedef enum logic [1:0] { S_IDLE, S_ACTIVE, S_DONE } state_e;`
#
# 2.8. Instances:
#      - `u_<ModuleName>` or `<module_name_instance_purpose>` (e.g., `u_data_fifo`, `data_path_fifo`). Be consistent.
#
# 2.9. Generate Blocks:
#      - `gen_<purpose>` (e.g., `gen_lanes[i].u_LaneLogic`).
#      - Ensure that there is no generate block labels that are identical.
#
# 2.10. Assertions and Sequences:
#      - `assert_<property_name>` for assertions.
#      - `seq_<sequence_name>` for sequences.
#      - `prop_<property_name>` for properties.
#      - `cg_<group_name>` for covergroups.
#      - `cp_<point_name>` for coverpoints.
#
#-------------------------------------------------------------------------------
# 3. Directory Structure
#-------------------------------------------------------------------------------
# project_root/
# ├── doc/                  // Design documents, specifications
# ├── rtl/                  // All synthesizable RTL SystemVerilog code (.sv)
# │   ├── config/           // Configuration packages and parameter definitions
# │   │   ├── global/       // Global system configuration
# │   │   ├── core/         // Core-specific configuration
# │   │   ├── memory/       // Memory subsystem configuration
# │   │   └── protocol/     // Protocol-specific configuration
# │   ├── protocol/         // Protocol implementations and adapters
# │   │   ├── axi/          // AXI protocol implementations
# │   │   ├── chi/          // CHI protocol implementations
# │   │   ├── tilelink/     // TileLink protocol implementations
# │   │   └── custom/       // Custom protocol implementations
# │   ├── shared/           // Shared/common modules and utilities
# │   │   ├── interfaces/   // Common interface definitions
# │   │   ├── primitives/   // Basic building blocks (FIFOs, arbiters, etc.)
# │   │   ├── utils/        // Utility modules and functions
# │   │   └── packages/     // Shared packages and type definitions
# │   ├── core/             // Core logic modules
# │   │   ├── pipeline/     // Pipeline stages
# │   │   ├── execution/    // Execution units
# │   │   ├── control/      // Control logic
# │   │   └── integration/  // Core integration modules
# │   ├── memory/           // Memory subsystem
# │   │   ├── cache/        // Cache implementations
# │   │   ├── coherency/    // Cache coherency logic
# │   │   ├── controllers/  // Memory controllers
# │   │   └── wrappers/     // Memory interface wrappers
# │   ├── units/            // Functional units (ALU, FPU, etc.)
# │   ├── power/            // Power management modules
# │   ├── peripherals/      // Peripheral modules
# │   └── verification/     // RTL verification helpers and checkers
# ├── tb/                   // Testbench code
# │   ├── top/              // Top-level testbench files (_tb.sv)
# │   ├── uvm/              // UVM components (agents, envs, sequences, tests)
# │   │   ├── agents/
# │   │   ├── envs/
# │   │   ├── sequences/
# │   │   └── tests/
# │   ├── common/           // Common testbench utilities, tasks, checkers
# │   └── vip/              // Verification IP
# ├── pkg/                  // SystemVerilog packages (.sv) (parameters, typedefs, utility functions)
# ├── syn/                  // Synthesis scripts, SDC constraints, reports
# │   ├── scripts/
# │   ├── constraints/      // Timing constraints (.sdc)
# │   └── reports/
# ├── formal/               // Formal verification scripts and properties
# ├── scripts/              // General utility scripts (lint, build, etc.)
# └── sim/                  // Simulation scripts, build directories (tool specific)
#
#-------------------------------------------------------------------------------
# 4. Module and Interface Declarations
#-------------------------------------------------------------------------------
# 4.1. File Header:
#      - Every `.sv` and `.svh` file must start with a standard header.
#
#        ```systemverilog
#        //=============================================================================
#        // Company: <Company Name>
#        // Project Name: <ProjectName>
#        //
#        // File: <FileName.sv> // The name of the current file.
#        //
#        // ----- Fields for Automated Documentation -----
#        // MODULE_NAME: <ModuleName> // Name of the module defined in this file.
#        // AUTHOR: <Author Name> (<author_email@company.com>) // Author of the module.
#        // VERSION: <X.Y.Z> // Version of the module.
#        // DATE: <YYYY-MM-DD> // Date of creation or last significant update.
#        // DESCRIPTION: <Brief, single-line description of the module's purpose.>
#        // PRIMARY_PURPOSE: <Detailed purpose of the module.>
#        // ROLE_IN_SYSTEM: <How this module fits into a larger system.>
#        // PROBLEM_SOLVED: <What specific problem this module addresses.>
#        // MODULE_TYPE: <e.g., RTL, Behavioral, Testbench_Component>
#        // TARGET_TECHNOLOGY_PREF: <ASIC/FPGA> // Preferred target technology.
#        // RELATED_SPECIFICATION: <Document_Name_Or_Link_to_Spec> // Link to relevant specs.
#        //
#        // ----- Status and Tracking -----
#        // VERIFICATION_STATUS: <Not Verified | In Progress | Verified | Formally Verified>
#        // QUALITY_STATUS: <Draft | Reviewed | Approved | Released>
#        //
#        //=============================================================================
#        //
#        `timescale 1ns/1ps
#        `default_nettype none // IMPORTANT: All signals must be explicitly typed
#        //
#        ```
# 4.1.1 File Footer:
#      - Every `.sv` and `.svh` file must end with a standard footer:
#        ```systemverilog
#        //=============================================================================
#        // Dependencies: <list of dependencies>
#        //
#        // Performance:
#        //   - Critical Path: <expected critical path>
#        //   - Max Frequency: <range of frequency>
#        //   - Area: <rough estimate>
#        //
#        // Verification Coverage:
#        //   - Code Coverage: <Coverage from tool>
#        //   - Functional Coverage: <Coverage from tool>
#        //   - Branch Coverage: <Coverage from tool>
#        //
#        // Synthesis:
#        //   - Target Technology: ASIC/FPGA
#        //   - Synthesis Tool: Design Compiler/Quartus
#        //   - Clock Domains: <number of clk domain>
#        //   - Constraints File: <SDC file name>
#        //
#        // Testing:
#        //   - Testbench: <testbench name>
#        //   - Test Vectors: <number of test vectors in testbench mentioned above>
#        //
#        //----------------------------------------------------------------------------
#        // Revision History:
#        // Version | Date       | Author             | Description
#        //=============================================================================
#        // 1.1.0   | YYYY-MM-DD | <Author Name>      | Added X / Implemented Y (Summary of changes)
#        // 1.0.0   | YYYY-MM-DD | <Author Name>      | Initial release
#        //=============================================================================
#        ```
#
# 4.2. Module Definition:
#      - Use ANSI-style port declarations.
#      - Parameters must explicitly be typed (e.g., `parameter integer DATA_WIDTH = 32`).
#      - Group ports by logical function (e.g., clock/reset, data_if, control_if) if numerous.
#      - Align port names, types, and comments for readability.
#      - Only declare 1 port or signal name per line
#
#        ```systemverilog
#        module MyModule #(
#            // Configurable Parameters (design-time configurable)
#            parameter integer CONFIG_DATA_WIDTH     = 32,    // Input/output data bus width
#            parameter integer CONFIG_FIFO_DEPTH     = 1024,  // Internal FIFO storage depth
#            parameter integer CONFIG_NUM_CHANNELS   = 4,     // Number of parallel channels
#            
#            // Type Parameters
#            parameter type    TYPE_ADDR          = logic [15:0], // Address type definition
#            parameter type    TYPE_USER          = logic [7:0],  // User-defined signal type
#            
#            // Design Constants (architectural constants)
#            parameter integer CONST_PIPELINE_STAGES = 3,    // Fixed number of pipeline stages
#            parameter integer CONST_RESET_CYCLES    = 10    // Reset synchronization cycles
#        ) (
#            // Clock and Reset
#            input  logic                clk_i,         // System clock
#            input  logic                rst_ni,        // Asynchronous active-low reset
#
#            // Data Input Interface
#            input  logic [CONFIG_DATA_WIDTH-1:0] din_data_i,
#            input  logic                         din_valid_i,
#            output logic                         din_ready_o,
#
#            // Control Signals
#            input  logic                enable_processing_i,
#            output logic                processing_done_o,
#
#            // Data Output Interface
#            output logic [CONFIG_DATA_WIDTH-1:0] dout_data_o,
#            output logic                         dout_valid_o,
#            input  logic                         dout_ready_i
#        );
#
#            //--------------------------------------------------------------------
#            // Local Parameters (derived from parameters and design constants)
#            //--------------------------------------------------------------------
#            localparam integer LP_INTERNAL_STAGES = CONST_PIPELINE_STAGES - 1;  // Derived from design constant
#            localparam integer LP_ADDR_BITS       = $clog2(CONFIG_FIFO_DEPTH);  // Calculated from configurable parameter
#            localparam integer LP_CHANNEL_BITS    = $clog2(CONFIG_NUM_CHANNELS); // Calculated bits for channel indexing
#            
#            // State encoding (internal FSM states)
#            localparam logic [1:0] S_IDLE = 2'b00;  // Idle state encoding
#            localparam logic [1:0] S_PROC = 2'b01;  // Processing state encoding
#            localparam logic [1:0] S_DONE = 2'b10;  // Done state encoding
#
#            //--------------------------------------------------------------------
#            // Internal Signal Declarations
#            //--------------------------------------------------------------------
#            // Registers
#            logic [CONFIG_DATA_WIDTH-1:0] data_pipeline_r   [LP_INTERNAL_STAGES];
#            logic                         data_valid_r      [LP_INTERNAL_STAGES];
#            logic [1:0]                   current_state_r;
#            logic [1:0]                   next_state_c; // Combinational logic for FSM next state
#
#            // Combinational signals / Wires
#            logic                         processed_data_valid_c;
#            logic [CONFIG_DATA_WIDTH-1:0] processed_data_c;
#            logic                         can_accept_input_c;
#            logic                         start_processing_c;
#
#            //--------------------------------------------------------------------
#            // Combinational Logic
#            //--------------------------------------------------------------------
#            assign can_accept_input_c = (current_state_r == S_IDLE) || !data_valid_r[0];
#            assign din_ready_o = can_accept_input_c; // Example output assignment
#
#            // Example: Simple data processing (e.g., increment)
#            always_comb begin : proc_data_processing
#                processed_data_c = data_pipeline_r[LP_INTERNAL_STAGES-1] + {{CONFIG_DATA_WIDTH-1{1'b0}}, 1'b1}; // Increment
#                processed_data_valid_c = data_valid_r[LP_INTERNAL_STAGES-1];
#            end
#
#            //--------------------------------------------------------------------
#            // Sequential Logic (Registers)
#            //--------------------------------------------------------------------
#            // Input data pipeline stage 0
#            always_ff @(posedge clk_i or negedge rst_ni) begin : proc_pipeline_stage_0
#                if (!rst_ni) begin
#                    data_pipeline_r[0] <= '0;
#                    data_valid_r[0]    <= 1'b0;
#                end else if (can_accept_input_c && din_valid_i) begin
#                    data_pipeline_r[0] <= din_data_i;
#                    data_valid_r[0]    <= 1'b1;
#                end else if (!data_valid_r[1]) begin // If next stage can accept
#                    data_valid_r[0]    <= 1'b0; // Data has moved or was invalid
#                end
#            end
#
#            // Subsequent pipeline stages
#            // NOTE: A generate block would be better for many stages
#            always_ff @(posedge clk_i or negedge rst_ni) begin : proc_pipeline_stage_1
#                if (!rst_ni) begin
#                    data_pipeline_r[1] <= '0;
#                    data_valid_r[1]    <= 1'b0;
#                end else begin
#                    data_pipeline_r[1] <= data_pipeline_r[0]; // Data from previous stage
#                    data_valid_r[1]    <= data_valid_r[0];    // Valid from previous stage
#                end
#            end
#
#            //--------------------------------------------------------------------
#            // Finite State Machine (FSM) Example
#            //--------------------------------------------------------------------
#            // FSM State Register
#            always_ff @(posedge clk_i or negedge rst_ni) begin : proc_fsm_state_reg
#                if (!rst_ni) begin
#                    current_state_r <= S_IDLE;
#                end else begin
#                    current_state_r <= next_state_c;
#                end
#            end
#
#            // FSM Next-State Logic
#            always_comb begin : proc_fsm_next_state
#                next_state_c = current_state_r; // Default: stay in current state
#                processing_done_o = 1'b0;       // Default output
#                start_processing_c = 1'b0;      // Default control
#
#                case (current_state_r)
#                    S_IDLE: begin
#                        if (din_valid_i && din_ready_o && enable_processing_i) begin
#                            next_state_c = S_PROC;
#                            start_processing_c = 1'b1; // hypothetical signal
#                        end
#                    end
#                    S_PROC: begin
#                        // Assume processing takes some cycles, check data_valid_r[LP_INTERNAL_STAGES-1]
#                        if (data_valid_r[LP_INTERNAL_STAGES-1]) begin // If data has passed through pipeline
#                            next_state_c = S_DONE;
#                        end
#                    end
#                    S_DONE: begin
#                        processing_done_o = 1'b1;
#                        if (dout_ready_i) begin // If downstream consumer is ready
#                            next_state_c = S_IDLE;
#                        end
#                    end
#                    default: begin // Should not happen with well-defined states
#                        next_state_c = S_IDLE;
#                    end
#                endcase
#            end
#
#            // FSM Output Logic (can also be registered)
#            assign dout_data_o  = (current_state_r == S_DONE) ? processed_data_c : '0;
#            assign dout_valid_o = (current_state_r == S_DONE) && processed_data_valid_c;
#
#            //--------------------------------------------------------------------
#            // Sub-module Instantiation Example
#            //--------------------------------------------------------------------
#            `ifdef SIMULATION // Example: A utility module only used in simulation
#            // Ensure MyUtilityModule.sv exists and is defined
#            // MyUtilityModule #(
#            //     .SOME_PARAM(32)
#            // ) u_my_utility_checker (
#            //     .clk_i          (clk_i),
#            //     .rst_ni         (rst_ni),
#            //     .check_signal_i (processed_data_c),
#            //     .error_flag_o   (/* connect to a monitor signal */)
#            // );
#            `endif
#
#            // TODO: Add assertions for critical properties, e.g., FSM state transitions
#            // TODO: Review reset conditions for all registers thoroughly
#
#        endmodule : MyModule
#        // `default_nettype wire // Revert default_nettype if absolutely necessary for legacy code,
#                               // but prefer keeping `none` throughout the project and explicitly
#                               // typing all signals. If reverted, do it at the end of the file.
#        ```
#
# 4.3. Interface Definition: Similar header and clarity as modules.
#      - Use modports to define perspectives (e.g., master, slave, monitor).
#      - Only declare 1 port or signal name per line
#
#        ```systemverilog
#        interface MyBus_if #(
#            // Configurable Parameters
#            parameter integer CONFIG_DATA_WIDTH = 32,  // Data bus width
#            parameter integer CONFIG_ADDR_WIDTH = 16   // Address bus width
#        ) (
#            input logic clk,
#            input logic rst_n
#        );
#            logic [CONFIG_ADDR_WIDTH-1:0] addr;
#            logic [CONFIG_DATA_WIDTH-1:0] wdata;
#            logic [CONFIG_DATA_WIDTH-1:0] rdata;
#            logic                  write_en;
#            logic                  read_en;
#            logic                  ready;
#            logic                  valid;
#
#            modport Master (
#                output addr, wdata, write_en, read_en,
#                input  rdata, ready, valid,
#                input  clk, rst_n
#            );
#
#            modport Slave (
#                input  addr, wdata, write_en, read_en,
#                output rdata, ready, valid,
#                input  clk, rst_n
#            );
#
#            modport Monitor (
#                input addr, wdata, rdata, write_en, read_en, ready, valid,
#                input clk, rst_n
#            );
#        endinterface : MyBus_if
#        ```
#
#-------------------------------------------------------------------------------
# 5. RTL Coding Style
#-------------------------------------------------------------------------------
# 5.1. Data Types:
#      - Use `logic` for general-purpose signals and ports. Avoid `wire` and `reg`
#        unless a specific reason exists (e.g., multiple drivers for `wire`).
#      - Use `bit` for 2-state variables when 4-state resolution is not needed (e.g., counters, flags in verification).
#      - Use `integer`, `int`, `byte`, `shortint`, `longint` where appropriate, especially for parameters and loop variables.
#      - Packed Structures: Always use packed structures (`struct packed`, `union packed`)
#        and packed arrays when bit-level concatenation or type casting is needed.
#        Ensure correct bit ordering.
#      - Enums: Use `enum` for FSM states and other sets of named constants.
#        Specify a base type if needed (e.g., `enum logic [2:0] { IDLE, RUN, DONE } state_e;`).
#
# 5.2. Procedural Blocks:
#      - `always_comb`: For purely combinational logic. Sensitive to all read signals.
#                       Avoid latches by ensuring all paths assign to all outputs.
#      - `always_ff`: For sequential logic (flip-flops). Must have a clock event.
#                     `@(posedge clk_i or negedge rst_ni)` for async reset.
#                     `@(posedge clk_i)`