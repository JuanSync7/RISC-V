---
description: Systemverilog Style Formatting. Must when generating Systemverilog code for consistency.
globs: 
alwaysApply: false
---
################################################################################
# ProjectName/TeamName SystemVerilog RTL Coding and Formatting Style Guide
# Version: 2.0
# Last Updated: 2025-05-25
################################################################################

#-------------------------------------------------------------------------------
# Introduction
#-------------------------------------------------------------------------------
# This document defines the SystemVerilog coding and formatting style for RTL
# design. Adherence to these guidelines is mandatory to ensure code
# consistency, readability, maintainability, and to facilitate collaboration,
# synthesis, and verification.
#
# This guide complements the IEEE 1800-2017 SystemVerilog standard.
# For language semantics and syntax, refer to IEEE 1800-2017.
#

#-------------------------------------------------------------------------------
# 1. General Formatting
#-------------------------------------------------------------------------------
# 1.1. Character Encoding:
#      - UTF-8
#
# 1.2. Line Length:
#      - Maximum 120 characters. Break longer lines for readability.
#
# 1.3. Indentation:
#      - 4 spaces per indentation level. Do NOT use tabs.
#
# 1.4. `timescale:
#      - `timescale 1ns/1ps must be declared at the top of every SystemVerilog
#        file (`.sv`, `.svh`).
#
# 1.5. `default_nettype:
#      - `default_nettype none must be used at the top of each RTL file
#        after `timescale to prevent implicit wire declarations.
#
# 1.6. Comments:
#      - // for single-line comments.
#      - /* ... */ for multi-line block comments (use sparingly in RTL, prefer //).
#      - Use meaningful comments to explain complex logic, design trade-offs,
#        or non-obvious code sections.
#      - Standard Tags:
#        // TODO: Item needing completion.
#        // FIXME: Item that is broken and needs fixing.
#        // NOTE: Important information or clarification.
#        // INFO: General information.
#        // WARNING: Potential issue or caution.
#        // REVIEW: Code section that needs review.
#
# 1.7. Preprocessor Directives for Simulation/Synthesis:
#      - Clearly delineate code sections for simulation-only or synthesis-only
#        using standard preprocessor directives:
#        `ifdef SIMULATION
#          // Simulation-only code (e.g., display statements, specific checks)
#        `endif
#
#        `ifdef SYNTHESIS
#          // Synthesis-only code (rare, usually for tool-specific attributes)
#        `else
#          // Code for non-synthesis tools or alternative implementation if SYNTHESIS is not defined
#        `endif
#
#        // Alternatively, for code to be excluded from synthesis:
#        // synthesis translate_off
#        ...
#        // synthesis translate_on

#-------------------------------------------------------------------------------
# 2. Naming Conventions
#-------------------------------------------------------------------------------
# 2.1. General:
#      - Use descriptive names. Avoid single-letter names except for loop variables (i, j, k).
#      - Use snake_case for signals, variables, and most identifiers unless specified.
#      - Use snake_case for module names, interface names, package names, class names, and typedefs.
#      - Use UPPER_CASE for parameters, localparams, and macros.
#
# 2.2. File Naming:
#      - RTL Modules:       module_name.sv          (e.g., data_processor.sv)
#      - Testbenches:       ModuleName_tb.sv       (e.g., data_processor_tb.sv)
#      - Packages:          feature_name_pkg.sv     (e.g., axi_utils_pkg.sv)
#      - Interfaces:        purpose_name_if.sv      (e.g., axi_stream_if.sv)
#      - Include Files:     header_name_hdr.svh     (e.g., defines_hdr.svh)
#      - Constraints:       module_name.sdc         (e.g., data_processor.sdc)
#
# 2.3. Module and Interface Names:
#      - snake_case (e.g., `my_module`, `standard_bus_if`).
#
# 2.4. Signal Naming:
#      - Suffixes:
#        - `_i`: input port
#        - `_o`: output port
#        - `_io`: inout port
#        - `_r`: registered signal (output of a flip-flop)
#        - `_ns`: next-state signal for a registered signal (combinational)
#        - `_c` or `_comb`: combinational logic signal (if clarity needed beyond _ns)
#        - `_w`: wire (explicitly, if needed for clarity, often implicit)
#        - `_en`: enable signal
#        - `_busy`: busy status signal
#        - `_valid`: valid signal
#        - `_ready`: ready signal
#        - `_ack`: acknowledge signal
#        - `_req`: request signal
#        - `_done`: done signal
#        - `_data`: data bus (e.g., `tx_data_i`, `mem_addr_o`)
#        - `_addr`: address bus
#        - `_wr`: write signal (e.g., `axi_awvalid_i`)
#        - `_rd`: read signal (e.g., `axi_arvalid_i`)
#        - `_sync`: signal synchronized across clock domains
#      - Prefixes:
#        - `clk_`: clock signals (e.g., `clk_core`, `clk_mem`)
#        - `rst_n_` or `arst_n_`: active-low asynchronous reset (project-specific choice, be consistent)
#        - `srst_n_` or `rst_n_`: active-low synchronous reset (project-specific choice, be consistent)
#        - `rst_p_`: active-high reset (less common for top-level resets)
#      - State Machine Signals:
#        - State register: `state_r`
#        - Next state logic: `state_ns`
#        - State encoding: `S_IDLE`, `S_FETCH`, `S_DECODE` (use enums for states)
#      - Bus Connections: Always `[MSB:LSB]` (e.g., `logic [31:0] data_bus;`)
#
# 2.5. Parameters and Localparams:
#      - UPPER_CASE_SNAKE_CASE (e.g., `DATA_WIDTH`, `FIFO_DEPTH`).
#      - Prefix `P_` for parameters if distinction from localparams is critical (e.g. `P_DATA_WIDTH`).
#      - Prefix `LP_` for localparams if distinction is critical.
#
# 2.6. Type Definitions (typedefs, enums, structs):
#      - typedefs uses snake_case with `_t` suffix (e.g., `address_t`, `state_type_t`, `config_bus_t`).
#      - enums uses snake_case with `_e` suffix (e.g., `color_e`, `machine_fsm_e`).
#      - structs uses snake_case with `_s` suffix (e.g., `write_addr_s`, `read_resp_s`)
#
# 2.7. Instances:
#      - `u_<ModuleName>` or `<module_name_instance_purpose>` (e.g., `u_data_fifo`, `data_path_fifo`). Be consistent.
#
# 2.8. Generate Blocks:
#      - `gen_<purpose>` (e.g., `gen_lanes[i].u_LaneLogic`).
#
# 2.9. Assertions and Sequences:
#      - `a_<property_name>` for assertions.
#      - `s_<sequence_name>` for sequences.
#      - `p_<property_name>` for properties.
#      - `cg_<group_name>` for covergroups.
#      - `cp_<point_name>` for coverpoints.
#
#-------------------------------------------------------------------------------
# 3. Directory Structure
#-------------------------------------------------------------------------------
# project_root/
# ├── doc/                  // Design documents, specifications
# ├── rtl/                  // All synthesizable RTL SystemVerilog code (.sv)
# │   ├── core/             // Core logic modules
# │   ├── interfaces/       // Interface definitions (.sv)
# │   └── common/           // Common utilities, shared modules
# ├── tb/                   // Testbench code
# │   ├── top/              // Top-level testbench files (_tb.sv)
# │   ├── uvm/              // UVM components (agents, envs, sequences, tests)
# │   │   ├── agents/
# │   │   ├── envs/
# │   │   ├── sequences/
# │   │   └── tests/
# │   ├── common/           // Common testbench utilities, tasks, checkers
# │   └── vip/              // Verification IP
# ├── pkg/                  // SystemVerilog packages (.sv) (parameters, typedefs, utility functions)
# ├── syn/                  // Synthesis scripts, SDC constraints, reports
# │   ├── scripts/
# │   ├── constraints/      // Timing constraints (.sdc)
# │   └── reports/
# ├── formal/               // Formal verification scripts and properties
# ├── scripts/              // General utility scripts (lint, build, etc.)
# └── sim/                  // Simulation scripts, build directories (tool specific)
#
#-------------------------------------------------------------------------------
# 4. Module and Interface Declarations
#-------------------------------------------------------------------------------
# 4.1. File Header:
#      - Every `.sv` and `.svh` file must start with a standard header:
#        ```systemverilog
#        //=============================================================================
#        // Company: <Company Name>
#        // Author: <Author Name> (<author_email@company.com>)
#        // Created: YYYY-MM-DD
#        //
#        // File: <FileName.sv>
#        // Module: <ModuleName> (if applicable)
#        //
#        // Project Name: <ProjectName>
#        // Target Devices: <Target Topology> (Usually ASIC or FPGA)
#        // Tool Versions: <Tool Name> (default is VCS)
#        // Verification Status: Not Verified/In Progress/Verified/Formally Verified
#        // Quality Status: Draft/Reviewed/Approved/Released
#        //
#        // Description:
#        //   <Brief, clear description of the file's/module's purpose and
#        //    functionality.>
#        //=============================================================================
#
# 4.1.1 File Footer:
#      - Every `.sv` and `.svh` file must end with a standard footer:
#        //=============================================================================
#        // Dependencies: <list of dependencies>
#        //
#        // Performance:
#        //   - Critical Path: <expected critical path>
#        //   - Max Frequency: <range of frequency>
#        //   - Area: <rough estimate>
#        //
#        // Verification Coverage:
#        //   - Code Coverage: <Coverage from tool>
#        //   - Functional Coverage: <Coverage from tool>
#        //   - Branch Coverage: <Coverage from tool>
#        //
#        // Synthesis:
#        //   - Target Technology: ASIC/FPGA
#        //   - Synthesis Tool: Design Compiler/Quartus
#        //   - Clock Domains: <number of clk domain>
#        //   - Constraints File: <SDC file name>
#        //
#        // Testing:
#        //   - Testbench: <testbench name>
#        //   - Test Vectors: <number of test vectors in testbench mentioned above>
#        //
#        //----------------------------------------------------------------------------
#        // Revision History:
#        // Version | Date       | Author             | Description
#        //=============================================================================
#        // 1.1.0   | YYYY-MM-DD | <Author Name>      | Added X / Implemented Y (Summary of changes)
#        // 1.0.0   | YYYY-MM-DD | <Author Name>      | Initial release
#        //=============================================================================
#        `timescale 1ns/1ps
#        `default_nettype none // IMPORTANT: All signals must be explicitly typed
#        ```
#
# 4.2. Module Definition:
#      - Use ANSI-style port declarations.
#      - Parameters must explicitly be typed (e.g., `parameter integer DATA_WIDTH = 32`).
#      - Group ports by logical function (e.g., clock/reset, data_if, control_if) if numerous.
#      - Align port names, types, and comments for readability.
#      - Only declare 1 port or signal name per line
#
#        ```systemverilog
#        module MyModule #(
#            parameter integer DATA_WIDTH     = 32,    // Description for DATA_WIDTH
#            parameter integer FIFO_DEPTH     = 1024,  // Description for FIFO_DEPTH
#            parameter type    ADDR_TYPE_T    = logic [15:0] // Example of type parameter
#        ) (
#            // Clock and Reset
#            input  logic                clk_i,         // System clock
#            input  logic                rst_ni,        // Asynchronous active-low reset
#
#            // Data Input Interface
#            input  logic [DATA_WIDTH-1:0] din_data_i,
#            input  logic                din_valid_i,
#            output logic                din_ready_o,
#
#            // Control Signals
#            input  logic                enable_processing_i,
#            output logic                processing_done_o,
#
#            // Data Output Interface
#            output logic [DATA_WIDTH-1:0] dout_data_o,
#            output logic                dout_valid_o,
#            input  logic                dout_ready_i
#        );
#
#            //--------------------------------------------------------------------
#            // Local Parameters
#            //--------------------------------------------------------------------
#            localparam integer INTERNAL_STAGES = 2;
#            localparam logic [1:0] S_IDLE  = 2'b00;
#            localparam logic [1:0] S_PROC  = 2'b01;
#            localparam logic [1:0] S_DONE  = 2'b10;
#
#            //--------------------------------------------------------------------
#            // Internal Signal Declarations
#            //--------------------------------------------------------------------
#            // Registers
#            logic [DATA_WIDTH-1:0] data_pipeline_r   [INTERNAL_STAGES];
#            logic                  data_valid_r      [INTERNAL_STAGES];
#            logic [1:0]            current_state_r;
#            logic [1:0]            next_state_c; // Combinational logic for FSM next state
#
#            // Combinational signals / Wires
#            logic                  processed_data_valid_c;
#            logic [DATA_WIDTH-1:0] processed_data_c;
#            logic                  can_accept_input_c;
#            logic                  start_processing_c;
#
#            //--------------------------------------------------------------------
#            // Combinational Logic
#            //--------------------------------------------------------------------
#            assign can_accept_input_c = (current_state_r == S_IDLE) || !data_valid_r[0];
#            assign din_ready_o = can_accept_input_c; // Example output assignment
#
#            // Example: Simple data processing (e.g., increment)
#            always_comb begin : proc_data_processing
#                processed_data_c = data_pipeline_r[INTERNAL_STAGES-1] + {{DATA_WIDTH-1{1'b0}}, 1'b1}; // Increment
#                processed_data_valid_c = data_valid_r[INTERNAL_STAGES-1];
#            end
#
#            //--------------------------------------------------------------------
#            // Sequential Logic (Registers)
#            //--------------------------------------------------------------------
#            // Input data pipeline stage 0
#            always_ff @(posedge clk_i or negedge rst_ni) begin : proc_pipeline_stage_0
#                if (!rst_ni) begin
#                    data_pipeline_r[0] <= '0;
#                    data_valid_r[0]    <= 1'b0;
#                end else if (can_accept_input_c && din_valid_i) begin
#                    data_pipeline_r[0] <= din_data_i;
#                    data_valid_r[0]    <= 1'b1;
#                end else if (!data_valid_r[1]) begin // If next stage can accept
#                    data_valid_r[0]    <= 1'b0; // Data has moved or was invalid
#                end
#            end
#
#            // Subsequent pipeline stages
#            // NOTE: A generate block would be better for many stages
#            always_ff @(posedge clk_i or negedge rst_ni) begin : proc_pipeline_stage_1
#                if (!rst_ni) begin
#                    data_pipeline_r[1] <= '0;
#                    data_valid_r[1]    <= 1'b0;
#                end else begin
#                    data_pipeline_r[1] <= data_pipeline_r[0]; // Data from previous stage
#                    data_valid_r[1]    <= data_valid_r[0];    // Valid from previous stage
#                end
#            end
#
#            //--------------------------------------------------------------------
#            // Finite State Machine (FSM) Example
#            //--------------------------------------------------------------------
#            // FSM State Register
#            always_ff @(posedge clk_i or negedge rst_ni) begin : proc_fsm_state_reg
#                if (!rst_ni) begin
#                    current_state_r <= S_IDLE;
#                end else begin
#                    current_state_r <= next_state_c;
#                end
#            end
#
#            // FSM Next-State Logic
#            always_comb begin : proc_fsm_next_state
#                next_state_c = current_state_r; // Default: stay in current state
#                processing_done_o = 1'b0;       // Default output
#                start_processing_c = 1'b0;      // Default control
#
#                case (current_state_r)
#                    S_IDLE: begin
#                        if (din_valid_i && din_ready_o && enable_processing_i) begin
#                            next_state_c = S_PROC;
#                            start_processing_c = 1'b1; // hypothetical signal
#                        end
#                    end
#                    S_PROC: begin
#                        // Assume processing takes some cycles, check data_valid_r[INTERNAL_STAGES-1]
#                        if (data_valid_r[INTERNAL_STAGES-1]) begin // If data has passed through pipeline
#                            next_state_c = S_DONE;
#                        end
#                    end
#                    S_DONE: begin
#                        processing_done_o = 1'b1;
#                        if (dout_ready_i) begin // If downstream consumer is ready
#                            next_state_c = S_IDLE;
#                        end
#                    end
#                    default: begin // Should not happen with well-defined states
#                        next_state_c = S_IDLE;
#                    end
#                endcase
#            end
#
#            // FSM Output Logic (can also be registered)
#            assign dout_data_o  = (current_state_r == S_DONE) ? processed_data_c : '0;
#            assign dout_valid_o = (current_state_r == S_DONE) && processed_data_valid_c;
#
#            //--------------------------------------------------------------------
#            // Sub-module Instantiation Example
#            //--------------------------------------------------------------------
#            `ifdef SIMULATION // Example: A utility module only used in simulation
#            // Ensure MyUtilityModule.sv exists and is defined
#            // MyUtilityModule #(
#            //     .SOME_PARAM(32)
#            // ) u_my_utility_checker (
#            //     .clk_i          (clk_i),
#            //     .rst_ni         (rst_ni),
#            //     .check_signal_i (processed_data_c),
#            //     .error_flag_o   (/* connect to a monitor signal */)
#            // );
#            `endif
#
#            // TODO: Add assertions for critical properties, e.g., FSM state transitions
#            // TODO: Review reset conditions for all registers thoroughly
#
#        endmodule : MyModule
#        // `default_nettype wire // Revert default_nettype if absolutely necessary for legacy code,
#                               // but prefer keeping `none` throughout the project and explicitly
#                               // typing all signals. If reverted, do it at the end of the file.
#        ```
#
# 4.3. Interface Definition: Similar header and clarity as modules.
#      - Use modports to define perspectives (e.g., master, slave, monitor).
#      - Only declare 1 port or signal name per line
#
#        ```systemverilog
#        interface MyBus_if #(
#            parameter integer DATA_WIDTH = 32,
#            parameter integer ADDR_WIDTH = 16
#        ) (
#            input logic clk,
#            input logic rst_n
#        );
#            logic [ADDR_WIDTH-1:0] addr;
#            logic [DATA_WIDTH-1:0] wdata;
#            logic [DATA_WIDTH-1:0] rdata;
#            logic                  write_en;
#            logic                  read_en;
#            logic                  ready;
#            logic                  valid;
#
#            modport Master (
#                output addr, wdata, write_en, read_en,
#                input  rdata, ready, valid,
#                input  clk, rst_n
#            );
#
#            modport Slave (
#                input  addr, wdata, write_en, read_en,
#                output rdata, ready, valid,
#                input  clk, rst_n
#            );
#
#            modport Monitor (
#                input addr, wdata, rdata, write_en, read_en, ready, valid,
#                input clk, rst_n
#            );
#        endinterface : MyBus_if
#        ```
#
#-------------------------------------------------------------------------------
# 5. RTL Coding Style
#-------------------------------------------------------------------------------
# 5.1. Data Types:
#      - Use `logic` for general-purpose signals and ports. Avoid `wire` and `reg`
#        unless a specific reason exists (e.g., multiple drivers for `wire`).
#      - Use `bit` for 2-state variables when 4-state resolution is not needed (e.g., counters, flags in verification).
#      - Use `integer`, `int`, `byte`, `shortint`, `longint` where appropriate, especially for parameters and loop variables.
#      - Packed Structures: Always use packed structures (`struct packed`, `union packed`)
#        and packed arrays when bit-level concatenation or type casting is needed.
#        Ensure correct bit ordering.
#      - Enums: Use `enum` for FSM states and other sets of named constants.
#        Specify a base type if needed (e.g., `enum logic [2:0] { IDLE, RUN, DONE } state_e;`).
#
# 5.2. Procedural Blocks:
#      - `always_comb`: For purely combinational logic. Sensitive to all read signals.
#                       Avoid latches by ensuring all paths assign to all outputs.
#      - `always_ff`: For sequential logic (flip-flops). Must have a clock event.
#                     `@(posedge clk_i or negedge rst_ni)` for async reset.
#                     `@(posedge clk_i)`