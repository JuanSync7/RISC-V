# Memory Management Unit (MMU) Implementation

## 1. Overview

This document details the implementation of the Memory Management Unit (MMU) within the RISC-V core. The MMU is responsible for translating virtual addresses generated by the CPU into physical addresses used by the memory subsystem, enforcing memory protection, and enabling virtual memory capabilities.

## 2. Module Structure

The MMU implementation is modular, residing in the `rtl/memory/mmu/` directory. It comprises the following key modules:

-   **`mmu_pkg.sv`**: Defines common data types, parameters, and constants used across all MMU-related modules, including `tlb_entry_t` for TLB entries and `mmu_request_t`/`mmu_response_t` for MMU interfaces.
-   **`tlb.sv`**: Implements the Translation Lookaside Buffer. This module acts as a cache for recently used virtual-to-physical address translations. It is a set-associative cache with configurable size and associativity (defined in `mmu_pkg.sv`). It handles TLB lookups and updates from the Page Table Walker.
-   **`page_table_walker.sv`**: This module is responsible for performing hardware-managed page table walks in main memory when a TLB miss occurs. It fetches Page Table Entries (PTEs) from memory and provides the translated physical address and permissions to the TLB for caching and to the main MMU module for immediate use. It interacts with the main memory bus.
-   **`mmu_csr.sv`**: Manages MMU-specific Control and Status Registers (CSRs), primarily the `satp` register, which holds the base address of the page tables and the MMU operating mode. It provides read/write access to these CSRs from the CPU.
-   **`mmu.sv`**: The top-level MMU module. It orchestrates the operations of the TLB, Page Table Walker, and MMU CSRs. It receives virtual address translation requests from the pipeline stages, attempts a TLB lookup, and if a miss occurs, initiates a page table walk. It outputs the translated physical address or a page fault exception.

## 3. Integration with the RISC-V Core

The MMU is integrated into the `core_subsystem.sv` module. The `ENABLE_MMU` parameter controls its instantiation and functionality.

-   **`core_subsystem.sv`**: Instantiates the `mmu.sv` module. It routes virtual address requests from the `fetch_stage.sv` (for instructions) and `execute_stage.sv` (for data loads/stores) to the MMU. The physical addresses returned by the MMU are then forwarded to the respective L1 caches (`icache.sv` and `dcache.sv`).
-   **`fetch_stage.sv`**: Sends instruction virtual addresses to the MMU for translation. It receives the physical address from the MMU and uses it to request instructions from the instruction cache.
-   **`execute_stage.sv`**: Sends data virtual addresses (for load/store operations) to the MMU for translation. It receives the physical address from the MMU and uses it to access the data cache.
-   **`mem_stage.sv`**: This stage now operates on physical addresses provided by the MMU, ensuring that all memory accesses are translated before reaching the memory hierarchy.

## 4. CSR Integration

The `mmu_csr.sv` module is connected to the core's main CSR bus. CSR read/write requests originating from the `execute_stage.sv` are routed through `core_subsystem.sv` to both the `mmu_csr.sv` and the general `csr_regfile.sv`. A multiplexer in `core_subsystem.sv` selects the correct CSR read data based on the address, prioritizing MMU CSRs when `ENABLE_MMU` is asserted.

## 5. Parameterization

The MMU's behavior is highly configurable through parameters defined in `mmu_pkg.sv`:

-   `MMU_TLB_SIZE`: Configures the total number of entries in the TLB.
-   `MMU_TLB_ASSOC`: Sets the associativity of the TLB (e.g., 2 for 2-way set-associative).
-   `MMU_PAGE_SIZE_BITS`: Defines the page size by specifying the log2 of the page size in bytes (e.g., 12 for 4KB pages).
-   `MMU_VADDR_WIDTH`: Specifies the width of virtual addresses.
-   `MMU_PADDR_WIDTH`: Specifies the width of physical addresses.

## 6. Exception Handling

The MMU is integrated with the core's exception handling mechanism. It generates page fault exceptions (instruction, load, store) and access fault exceptions when memory access violations or invalid translations occur. These exceptions are propagated through the pipeline and handled by the core's exception unit.
